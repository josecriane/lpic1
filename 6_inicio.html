<!DOCTYPE html>
<html>
<head>
	<meta charset="utf-8">
	<meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
	<meta name="viewport" content="width=1024, user-scalable=no">

	<title>LPIC Slides</title>
	
	<!-- Required stylesheet -->
	<link rel="stylesheet" href="core/deck.core.css">
	<link rel="stylesheet" href="extensions/status/deck.status.css">
	<link rel="stylesheet" href="extensions/scale/deck.scale.css">
	<link rel="stylesheet" href="extensions/hash/deck.hash.css">

	<link rel="stylesheet" href="themes/style/lpic_slides.css">
	<link rel="stylesheet" href="themes/transition/horizontal-slide.css">
	
	<!-- Required Modernizr file -->
	<script src="modernizr.custom.js"></script>
</head>
<body>

	<header>
		<span><a href="http://josecriane.com/lpic/">Inicio</a></span>
	</header>

<!-- Begin slides. Just make elements with a class of slide. -->
	<article class="deck-container">
		<section class="slide">
			<h1>Edición e Inicio de Linux.</h1>
		</section>

		<section class="slide">
			<h2>Vi / Vim</h2>
			<p>Vi es el editor de textos, que hay en todas las distribuciones Linux. Vim es lo que Vi siempre quiso ser. En sistemas Linux como RedHat Vi es un enlace a Vim.</p>
			<ul>
				<li class="slide">
					Para aprender a usar vim, usaremos un programa que se llama <code>vimtutor</code>, este comando nos guiará para aprender a usar Vim de forma que podremos convertirlo en nuestro editor habitual en la terminal.
				</li>
				<li class="slide">
					Existen otra serie de alternativas para editar ficheros en Linux pero no están tan extendidas.
					<ul>
						<li class="slide"><strong>Nano</strong>: El otro gran editor de texto, viene instalado por defecto en un gran numero de distribuciones.</li>
						<li class="slide"><strong>Pico</strong>: Similar a nano.</li>
						<li class="slide"><strong>Joe</strong>: Editor muy potente creado y mantenido por la comunidad GNU.</li>
					</ul>
				</li> 
				<li class="slide">
					<p>Arranque del SO.</p>
					<ul>
						<li class="slide">
							Sistemas a escoger como cargador de Arranque, este es el que se encargará de cargar y lanzar el sistema operativo necesario.
						</li>
						<li class="slide">
							<strong>Lilo</strong>, actualmente menos usado, empezó siendo el Rey de los cargadores de arranque y actualmente aun se utiliza ya que es muy ligero y sencillo.
						</li>
						<li class="slide">
							<strong>Grub</strong>, domina el mercado, gracias a las ventajas que ofrece contra Lilo, como que no es necesario que se reinstale en el MBR cada vez que cambiamos la configuración del cargador.
						</li>
					</ul>
				</li>
			</ul>
			<p class="deck-status">
				<span class="deck-status-current"></span>/<span class="deck-status-total"></span>
			</p>
		</section>

		<section class="slide">
			<h2>LILO</h2>
			<ul>
				<li>
					Para configurar LILO usaremos el siguiente fichero, /etc/lilo.conf.
				</li>
				<li class="slide">
					Las opciones del fichero se basan en pares, <code>opcion=valor</code> y las opciones más clásicas, y con las que seguramente consigas lo que quieres son:
				</li> 
				<li class="slide">
					<strong>boot=</strong>: Nos indica en el MBR de que disco duro se encuentra el cargador de arranque
				</li>
				<li class="slide">
					<strong>default=</strong>: Sirve para indicar cual de las opciones de sistemas operativos vamos arrancar por defecto.
				</li>
				<li class="slide">
					<strong>timeout=</strong>: Tiempo de espera para escoger el SO que arrancará, después del tiempo de espera se arrancará el SO por defecto.
				</li>
			</ul>
			<p class="deck-status">
				<span class="deck-status-current"></span>/<span class="deck-status-total"></span>
			</p>
		</section>

		<section class="slide">
			<h2>Configurando LILO para arrancar el SO</h2>
			<ul>
				<li>
					Usaremos las siguiente etiquetas para decidir indicarle que distribuciones vamos a usar.
				</li> 
				<li class="slide">
					<strong>image=</strong>, indica el fichero del kernel a usar en el arranque. Cada vez que ponemos esta empezamos a colocar un so nuevo en LILO debemos empezar con esta linea, ya que LILO entiende que la entrada del SO empieza con esta linea.
				</li> 
				<li class="slide">
					<strong>other=</strong>, si queremos indicarle a LILO que queremos arrancar un so que no sea Linux.
				</li>
				<li class="slide">
					<strong>label=</strong>, etiqueta con la que distinguiremos el SO, que queramos arrancar.
				</li>
			</ul>
			<p class="slide">Una vez cambiado el SO, debemos ejecutar <code>lilo</code>, para que lilo se reinstale en el MBR</p>
			<p class="deck-status">
				<span class="deck-status-current"></span>/<span class="deck-status-total"></span>
			</p>
		</section>

		<section class="slide">
			<h2>GRUB</h2>
			<ul>
				<li>
					Para configurar GRUB usaremos el siguiente fichero, <code>/boot/grub/menu.lst</code> o <code>/boot/grub/grub.conf</code>.
				</li>
				<li class="slide">
					Antes de empezar hay que tener en cuenta que para grub el disco duro <code>/dev/hda</code> será <code>(hd0)</code> y la primera partición lógica<code>/dev/hda5</code> será <code>(hd0, 0)</code>, todos estos mapeos podemos verlos en el fichero <code>/boot/grub/device.map</code>, las opciones más habituales de grub son:
				</li> 
				<li class="slide">
					<strong>splashimage=</strong>: Indica una imagen que se cargará de fondo en el grub.
				</li>
				<li class="slide">
					<strong>default=</strong>: Sirve para indicar cual de las opciones de sistemas operativos vamos arrancar por defecto.
				</li>
				<li class="slide">
					<strong>timeout=</strong>: Tiempo de espera para escoger el SO que arrancará, después del tiempo de espera se arrancará el SO por defecto.
				</li>
			</ul>
			<p class="deck-status">
				<span class="deck-status-current"></span>/<span class="deck-status-total"></span>
			</p>
		</section>

		<section class="slide">
			<h2>Configurando GRUB para arrancar el SO</h2>
			<ul>
				<li>
					Usaremos las siguiente etiquetas para decidir indicarle que distribuciones vamos a usar.
				</li> 
				<li class="slide">
					<strong>root</strong>, es la partición donde se encuentra instalado grub. 
				</li> 
				<li class="slide">
					<strong>kernel</strong>, indica el fichero del kernel a usar en el arranque, además aquí se suele indicar como montar el sistema y otras opciones relativas al arranque del kernel.
				</li>
				<li class="slide">
					<strong>title</strong>, etiqueta con la que distinguiremos el SO, que queramos arrancar. Cada vez que ponemos esta empezamos a colocar un so nuevo en GRUB debemos empezar con esta linea, ya que GRUB entiende que la entrada del SO empieza con esta linea.
				</li>
				<li class="slide">
					<strong>rootnoverify</strong>, si queremos indicarle a GRUB que queremos arrancar un so que no sea Linux.
				</li>
			</ul>
			<p class="slide">Si ya teníamos GRUB instalado en el MBR de alguna partición no será necesario nada más, en caso contrario deberemos lanzar <code>grub-install /dev/hda</code><p>
			<p class="deck-status">
				<span class="deck-status-current"></span>/<span class="deck-status-total"></span>
			</p>
		</section>

		<section class="slide">
			<h2>Proceso de Arranque.</h2>
			<ul>
				<li class="class">
					<ul>
						<li class="class">Arranca la BIOS y esta hace un checkeo del Hardware</li>
						<li class="class">La BIOS llama al gestor de arranque.</li>
						<li class="class">El gestor de arranque llama al kernel del sistema.</li>
						<li class="class">El kernel inicia los dispositivos, montar las particiones, arranca <code>/sbin/init</code>.</li>
						<li class="class"><code>/sbin/init</code> lee <code>/etc/inittab</code>, para ver que programas ejecutar aquí se establecen los scripts de inicio.</li>
					</ul>
				</li>
				<li class="slide">
					Linux al arrancar nos irá dando información del proceso de arranque, kernel ring buffer, pero estos mensajes suelen pasar muy rápido, o el sistema no nos los muestra, para ver todos los mensajes del proceso de arranque podemos usar, dmesg. Algunos sistemas Linux guardan esta información en <code>/var/log/dmesg</code>.
				</li>

				<li class="slide">
					También podemos revisar el registro de syslogd, en <code>/var/log/messages</code>.
				</li>
			</ul>
			<p class="deck-status">
				<span class="deck-status-current"></span>/<span class="deck-status-total"></span>
			</p>
		</section>

		<section class="slide">
			<h2>Entendiendo syslogd y dmesg</h2>
			<ul>
				<li class="slide">
					Linux al arrancar nos irá dando información del proceso de arranque, kernel ring buffer, pero estos mensajes suelen pasar muy rápido, o el sistema no nos los muestra, para ver todos los mensajes del proceso de arranque podemos usar, dmesg. Algunos sistemas Linux guardan esta información en <code>/var/log/dmesg</code>.
				</li>

				<li class="slide">
					También podemos revisar el registro de syslogd, en <code>/var/log/messages</code>.
				</li>
				<li class="slide">
					Usaremos less para filtra el contenido que no nos interesa, para ellos tenemos que usar <code>/</code> y a continuación lo que buscamos.
				</li>
				<li class="slide">Buscaremos por nombre, el tipo de hardware que nos interesa, por ejemplo USB.</li>
				<li class="slide">Buscar por el nombre del chipset o del fabricante del hardware que quieres buscar.</li>
			</ul>
			<p class="deck-status">
				<span class="deck-status-current"></span>/<span class="deck-status-total"></span>
			</p>
		</section>

		<section class="slide">
			<h2>Modos de Ejecución</h2>
			<ul>
				<li class="slide"><strong>0</strong>: Modo transitorio, se usa para que el sistema pase de un estado a otro.</li>
				<li class="slide"><strong>1</strong>: Modo monousuario, se usa para realizar mantenimiento del sistema, por si el funcionamiento normal pudiese afectarle.</li>
				<li class="slide"><strong>2</strong>: En Debian es el modo multiusuario, con las X, es el modo de trabajo normal del usuario, otras distribuciones dejan sin definir este modo</li>
				<li class="slide"><strong>3</strong>: En las distribuciones no basadas en Debian es igual que el modo 2 para Debian, sin el acceso a las X de forma gráfica</li>
				<li class="slide"><strong>4</strong>: Sin definir, suele usarse para opciones personalizadas.</li>
				<li class="slide"><strong>5</strong>: En las distribuciones no basadas en Debian es igual que el modo 2.</li>
				<li class="slide"><strong>6</strong>: Otro modo transitorio, que se usar para reiniciar el sistema.</li>
			</ul>
			<p class="slide">Cada modo de ejecución tendrá sus propios scripts.</p>
			<p class="deck-status">
				<span class="deck-status-current"></span>/<span class="deck-status-total"></span>
			</p>
		</section>

		<section class="slide">
			<h2>Inittab</h2>
			<pre>id:modo:acción:proceso</pre>
			<ul>
				<li class="slide">
					<strong>id</strong>: Identifica la función de inicio, puede tener hasta 4 caracteres
				</li>
				<li class="slide">
					<strong>modo</strong>: Modo de ejecución, implica a que modos de ejecución se aplicará esta entrada.
				</li>
				<li class="slide">
					<strong>acción</strong>: indica a <code>init</code> que acción realizar, wait, respawn..., el primero le dice que tiene que esperar a que espere hasta que se realice, y el segundo le dice que reinicie el proceso cuando este termine. 
				</li>
				<li class="slide">
					<strong>proceso</strong>: Indica que es lo que tiene que hacer, poniendo también todas los parámetros que se necesiten.
				</li>
			</ul>
			<p class="slide">Actualmente, hay sistemas que usan <code>/etc/event.d</code> en lugar de los scripts de SysV, que veremos a continuación.</p>
		</section>

		<section class="slide">
			<h2>SysV</h2>
			<ul>
				<li class="slide">
					Se trata de los scripts que se lanzan en los modos de ejecución específicos, y se encuentran en <code>/etc/init.d/rc</code>.
				</li>
				<li class="slide">
					Los scripts que comienzan por S se les pasa el parámetro start, cuando se lanza ese modo de ejecución. 
				</li>
				<li class="slide">
					Los scripts que comienzan por K se les pasa el parámetro stop, cuando se lanza el modo de ejecución.
				</li>
				<li class="slide">
					Además estos scripts cuentan con un numero que será el orden en el que se ejecutará.
				</li>
			</ul>
		</section>


	</article>
<!-- End slides. -->

<!-- Required JS files. -->
<script src="jquery-1.7.2.min.js"></script>
<script src="core/deck.core.js"></script>
<script src="extensions/hash/deck.hash.js"></script>
<script src="extensions/status/deck.status.js"></script>
<script src="extensions/scale/deck.scale.js"></script>

<!-- Initialize the deck. You can put this in an external file if desired. -->
<script>
	$(function() {
		$.deck('.slide');
	});
</script>
</body>
</html>
